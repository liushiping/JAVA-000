不同GC的总结
 - 串行 GC（Serial GC）/ParNewGC
    - 串行 GC 对年轻代使用 mark-copy（标记-复制） 算法，对老年代使用 mark-sweep-compact
      （标记-清除-整理）算法。
    - 两者都是单线程的垃圾收集器，不能进行并行处理，所以都会触发全线暂停（STW），停止所
      有的应用线程。
    - CPU 利用率高，暂停时间长；
 - 并行 GC（Parallel GC）
    - 年轻代和老年代的垃圾回收都会触发 STW 事件；
    - 在年轻代使用 标记-复制（mark-copy）算法，在老年代使用 标记-清除-整理（mark-sweep-
      compact）算法；
    - 并行垃圾收集器适用于多核服务器，主要目标是增加吞吐量。因为对系统资源的有效使用，能达到
      更高的吞吐量:
    - 在 GC 期间，所有 CPU 内核都在并行清理垃圾，所以总暂停时间更短；
    - 在两次 GC 周期的间隔期，没有 GC 线程在运行，不会消耗任何系统资源；
 - CMS GC
    - 其对年轻代采用并行 STW 方式的 mark-copy (标记-复制)算法，对老年代主要使用并发 mark-
      sweep (标记-清除)算法；
    - 不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收；
    - 在 mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行；
    - 默认情况下，CMS 使用的并发线程数等于 CPU 核心数的 1/4；
    - 如果服务器是多核 CPU，并且主要调优目标是降低 GC 停顿导致的系统延迟，那么使用 CMS 是
      个很明智的选择。进行老年代的并发回收时，可能会伴随着多次年轻代的 minor GC；
 - G1 GC
    - G1 GC 最主要的设计目标是：将 STW 停顿的时间
      和分布，变成可预期且可配置的；
    - 堆不再分成年轻代和老年代，而是划分为多
      个（通常是 2048 个）可以存放对象的 小块堆区域
      (smaller heap regions)。每个小块，可能一会被
      定义成 Eden 区，一会被指定为 Survivor区或者
      Old 区。在逻辑上，所有的 Eden 区和 Survivor
      区合起来就是年轻代，所有的 Old 区拼在一起那
      就是老年代；
    - 每
      次只处理一部分内存块，称为此次 GC 的回收
      集(collection set)。每次 GC 暂停都会收集所
      有年轻代的内存块，但一般只包含部分老年代
      的内存块；
    - 在并发阶段估算每个小
      堆块存活对象的总数。构建回收集的原则是：
      垃圾最多的小块会被优先收集；
 - ZGC
      1. GC 最大停顿时间不超过 10ms
      2. 堆内存支持范围广，小至几百 MB 的堆空间，大至 4TB 的超大堆
      内存（JDK13 升至 16TB）
      3. 与 G1 相比，应用吞吐量下降不超过 15%；
 - GC总结
    - 1. 串行 GC（Serial GC）: 单线程执行，应用需要暂停；
      2. 并行 GC（ParNew、Parallel Scavenge、Parallel Old）: 多线程并行地执行垃圾回收，
      关注与高吞吐；
      3. CMS（Concurrent Mark-Sweep）: 多线程并发标记和清除，关注与降低延迟；
      4. G1（G First）: 通过划分多个内存区域做增量整理和回收，进一步降低延迟；
      5. ZGC（Z Garbage Collector）: 通过着色指针和读屏障，实现几乎全部的并发执行，几毫
      秒级别的延迟，线性可扩展；
